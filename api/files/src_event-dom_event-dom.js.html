<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/event-dom/event-dom.js - Parcela</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Parcela"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Parcel.html">Parcel</a></li>
            
                <li><a href="../classes/Parcel.EventListener.html">Parcel.EventListener</a></li>
            
                <li><a href="../classes/Parcel.Listener.html">Parcel.Listener</a></li>
            
                <li><a href="../classes/Parcela.html">Parcela</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/Promise.Resolver.html">Promise.Resolver</a></li>
            
                <li><a href="../classes/Router.html">Router</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vDOM.html">vDOM</a></li>
            
                <li><a href="../classes/vNode.html">vNode</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/core.html">core</a></li>
            
                <li><a href="../modules/core-event.html">core-event</a></li>
            
                <li><a href="../modules/core-event-base.html">core-event-base</a></li>
            
                <li><a href="../modules/core-routing.html">core-routing</a></li>
            
                <li><a href="../modules/core-timers.html">core-timers</a></li>
            
                <li><a href="../modules/core-utils.html">core-utils</a></li>
            
                <li><a href="../modules/core-vdom.html">core-vdom</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hammerjs.html">event-hammerjs</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-node.html">io-node</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-win.html">io-win</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/Object.html">Object</a></li>
            
                <li><a href="../modules/parcel.html">parcel</a></li>
            
                <li><a href="../modules/parcel-event-listener.html">parcel-event-listener</a></li>
            
                <li><a href="../modules/Parcela.html">Parcela</a></li>
            
                <li><a href="../modules/Promise.html">Promise</a></li>
            
                <li><a href="../modules/promise-ext.html">promise-ext</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/virtual-dom.html">virtual-dom</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/event-dom/event-dom.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* globals window:true, document:true, Element:true */

&quot;use strict&quot;;

/**
 * Integrates DOM-events to core-event-base. more about DOM-events:
 * http://www.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/
 *
 * Should be called using  the provided &#x60;mergeInto&#x60;-method like this:
 *
 * @example
 * Event = require(&#x27;event&#x27;);
 * DOMEvent = require(&#x27;event-dom&#x27;);
 * DOMEvent.mergeInto(Event);
 *
 * @module event
 * @submodule event-dom
 * @class Event
 * @since 0.0.1
 *
 * &lt;i&gt;Copyright (c) 2014 Parcela - https://github.com/Parcela&lt;/i&gt;
 * New BSD License - https://github.com/ItsAsbreuk/itsa-library/blob/master/LICENSE
 *
*/


var NAME = &#x27;[event-dom]: &#x27;,
    Event = require(&#x27;event&#x27;),
    async = require(&#x27;utils&#x27;).async,
    PARCELA_EMITTER = &#x27;ParcelaEvent&#x27;,
    OUTSIDE = &#x27;outside&#x27;,
    REGEXP_UI = /^UI:/,
    REGEXP_NODE_ID = /^#\S+$/,
    REGEXP_EXTRACT_NODE_ID = /#(\S+)/,
    REGEXP_UI_OUTSIDE = /^.+outside$/,
    /*
     * Internal hash containing all DOM-events that are listened for (at &#x60;document&#x60;).
     *
     * DOMEvents = {
     *     &#x27;click&#x27;: callbackFn,
     *     &#x27;mousemove&#x27;: callbackFn,
     *     &#x27;keypress&#x27;: callbackFn
     * }
     *
     * @property DOMEvents
     * @default {}
     * @type Object
     * @private
     * @since 0.0.1
    */
    DOMEvents = {};

module.exports = function (window) {
    var DOCUMENT = window.document,
        NEW_EVENTSYSTEM = DOCUMENT.addEventListener,
        OLD_EVENTSYSTEM = !NEW_EVENTSYSTEM &amp;&amp; DOCUMENT.attachEvent,
        DOM_Events, _bubbleIE8, _domSelToFunc, _evCallback, _findCurrentTargets, _preProcessor,
        _filter, _setupDomListener, _sortFunc;

    window.Parcela || (window.Parcela={});
    window.Parcela.modules || (window.Parcela.modules={});

    if (window.Parcela.modules.EventDom) {
        return Event; // Event was already extended
    }

    // polyfill for Element.matchesSelector
    // based upon https://gist.github.com/jonathantneal/3062955
    window.Element &amp;&amp; function(ElementPrototype) {
        ElementPrototype.matchesSelector = ElementPrototype.matchesSelector ||
        ElementPrototype.mozMatchesSelector ||
        ElementPrototype.msMatchesSelector ||
        ElementPrototype.oMatchesSelector ||
        ElementPrototype.webkitMatchesSelector ||
        function (selector) {
            var node = this,
                nodes = (node.parentNode || DOCUMENT).querySelectorAll(selector),
                i = -1;
            while (nodes[++i] &amp;&amp; (nodes[i] !== node));
            return !!nodes[i];
        };
    }(window.Element.prototype);

    /*
     * Polyfill for bubbling the &#x60;focus&#x60; and &#x60;blur&#x60; events in IE8.
     *
     * IE&gt;8 we can use delegating on ALL events, because we use the capture-phase.
     * Unfortunatly this cannot be done with IE&lt;9. But we can simulate focus and blur
     * delegation bu monitoring the focussed node.
     *
     * This means the IE&lt;9 will miss the events: &#x27;error&#x27;, &#x27;load&#x27;, &#x27;resize&#x27; and &#x27;scroll&#x27;
     * However, if you need one of these to work in IE8, then you can &#x60;activate&#x60; this event on the
     * single node that you want to minotor. You activate it and then you use the eventsystem
     * like like you are used to. (delegated). Only activated nodes will bubble their non-bubbling events up
     * Activation is not done manually, but automaticly: whenever there is a subscriber on a node (or an id-selector)
     * and IE&lt;9 is the environment, then a listener for that node is set up.
     * Side-effect is that we cannot controll when the listener isn&#x27;t needed anymore. This might lead to memory-leak - but its IE&lt;9...
     *
     * @method _bubbleIE8
     * @private
     * @since 0.0.1
     */
    _bubbleIE8 = function() {
        console.log(NAME, &#x27;_bubbleIE8&#x27;);
        // we wil emulate focus and blur by subscribing to the keyup and mouseup events:
        // when they happen, we&#x27;ll ask for the current focussed Node --&gt; if there is a
        // change compared to the previous, then we fire both a blur and a focus-event
        Event._focussedNode = DOCUMENT.activeElement;
        Event.after([&#x27;keyup&#x27;, &#x27;mouseup&#x27;], function(e) {
            var newFocussed = DOCUMENT.activeElement,
                prevFocussed = Event._focussedNode;
            if (prevFocussed !== newFocussed) {
                Event._focussedNode = newFocussed;
                Event.emit(prevFocussed, &#x27;UI:blur&#x27;, e);
                Event.emit(newFocussed, &#x27;UI:focus&#x27;, e);
            }
        });
    };

    /*
     * Creates a filterfunction out of a css-selector. To be used for catching any dom-element, without restrictions
     * of any context (like Parcels can --&gt; Parcel.Event uses _parcelSelToDom instead)
     * On &quot;non-outside&quot; events, subscriber.t is set to the node that first matches the selector
     * so it can be used to set as e.target in the final subscriber
     *
     * @method _domSelToFunc
     * @param ev {Object} eventobject
     * @param ev.subscriber {Object} subscriber
     * @param ev.subscriber.o {Object} context
     * @param ev.subscriber.cb {Function} callbackFn
     * @param ev.subscriber.f {Function|String} filter
     * @param ev.subscriber.n {dom-node} becomes e.currentTarget
     * @param ev.subscriber.t {dom-node} becomes e.target
     * @param ev.customEvent {String}
     * @private
     * @since 0.0.1
     */
    _domSelToFunc = function(ev) {
        // this stage is runned during subscription
        var outsideEvent = REGEXP_UI_OUTSIDE.test(ev.customEvent),
            selector = ev.subscriber.f,
            nodeid, byExactId;

        console.log(NAME, &#x27;_domSelToFunc type of selector = &#x27;+typeof selector);
        // note: selector could still be a function: in case another ev.subscriber
        // already changed it.
        if (!selector || (typeof selector === &#x27;function&#x27;)) {
            ev.subscriber.n || (ev.subscriber.n=DOCUMENT);
            return;
        }

        nodeid = selector.match(REGEXP_EXTRACT_NODE_ID);
        nodeid ? (ev.subscriber.nId=nodeid[1]) : (ev.subscriber.n=DOCUMENT);

        byExactId = REGEXP_NODE_ID.test(selector);

        ev.subscriber.f = function(e) {
            // this stage is runned when the event happens
            console.log(NAME, &#x27;_domSelToFunc inside filter. selector: &#x27;+selector);
            var node = e.target,
                match = false;
            // e.target is the most deeply node in the dom-tree that caught the event
            // our listener uses &#x60;selector&#x60; which might be a node higher up the tree.
            // we will reset e.target to this node (if there is a match)
            // note that e.currentTarget will always be &#x60;document&#x60; --&gt; we&#x27;re not interested in that
            // also, we don&#x27;t check for &#x60;node&#x60;, but for node.matchesSelector: the highest level &#x60;document&#x60;
            // is not null, yet it doesn;t have .matchesSelector so it would fail
            while (node.matchesSelector &amp;&amp; !match) {
                console.log(NAME, &#x27;_domSelToFunc inside filter check match&#x27;);
                match = byExactId ? (node.id===selector.substr(1)) : node.matchesSelector(selector);
                // if there is a match, then set
                // e.target to the target that matches the selector
                if (match &amp;&amp; !outsideEvent) {
                    ev.subscriber.t = node;
                }
                node = node.parentNode;
            }
            console.log(NAME, &#x27;_domSelToFunc filter returns &#x27;+(!outsideEvent ? match : !match));
            return !outsideEvent ? match : !match;
        };
    };

    // at this point, we need to find out what are the current node-refs. whenever there is
    // a filter that starts with &#x60;#&#x60; --&gt; in those cases we have a bubble-chain, because the selector isn&#x27;t
    // set up with &#x60;document&#x60; at its root.
    // we couldn&#x27;t do this at time of subscribtion, for the nodes might not be there at that time.
    // however, we only need to do this once: we store the value if we find them
    // no problem when the nodes leave the dom later: the previous filter wouldn&#x27;t pass
    _findCurrentTargets = function(subscribers) {
        console.log(NAME, &#x27;_findCurrentTargets&#x27;);
        subscribers.forEach(
            function(subscriber) {
                console.log(NAME, &#x27;_findCurrentTargets for single subscriber. nId: &#x27;+subscriber.nId);
                subscriber.nId &amp;&amp; (subscriber.n=DOCUMENT.getElementById(subscriber.nId));
            }
        );
    };

    /*
     * Generates an event through our Event-system. Does the actual transportation from DOM-events
     * into our Eventsystem. It also looks at the response of our Eventsystem: if our system
     * halts or preventDefaults the customEvent, then the original DOM-event will be preventDefaulted.
     *
     * @method _evCallback
     * @param e {Object} eventobject
     * @private
     * @since 0.0.1
     */
    _evCallback = function(e) {
        console.log(NAME, &#x27;_evCallback&#x27;);
        var beforeSubscribers = [],
            afterSubscribers = [],
            allSubscribers = Event._subs,
            eventName = e.type,
            customEvent = &#x27;UI:&#x27;+eventName,
            eventobject, subs, wildcard_named_subs, named_wildcard_subs, wildcard_wildcard_subs,
            beforeSubscribersOutside, afterSubscribersOutside, outsideEvent, eventobjectOutside;

        subs = allSubscribers[customEvent];
        wildcard_named_subs = allSubscribers[&#x27;*:&#x27;+eventName];
        named_wildcard_subs = allSubscribers[&#x27;UI:*&#x27;];
        wildcard_wildcard_subs = allSubscribers[&#x27;*:*&#x27;];

        subs &amp;&amp; subs.b &amp;&amp; (beforeSubscribers=beforeSubscribers.concat(subs.b));
        wildcard_named_subs &amp;&amp; wildcard_named_subs.b &amp;&amp; (beforeSubscribers=beforeSubscribers.concat(wildcard_named_subs.b));
        named_wildcard_subs &amp;&amp; named_wildcard_subs.b &amp;&amp; (beforeSubscribers=beforeSubscribers.concat(named_wildcard_subs.b));
        wildcard_wildcard_subs &amp;&amp; wildcard_wildcard_subs.b &amp;&amp; (beforeSubscribers=beforeSubscribers.concat(wildcard_wildcard_subs.b));

        if (beforeSubscribers.length&gt;0) {
            beforeSubscribers = _filter(beforeSubscribers, e);
            if (beforeSubscribers.length&gt;0) {
                _findCurrentTargets(beforeSubscribers);
                // sorting, based upon the sortFn
                beforeSubscribers.sort(_sortFunc);
            }
        }

        outsideEvent = REGEXP_UI_OUTSIDE.test(e.type);
        if (outsideEvent) {
            beforeSubscribersOutside = [];
            afterSubscribersOutside = [];
            subs &amp;&amp; subs.b &amp;&amp; (beforeSubscribersOutside=beforeSubscribersOutside.concat(subs.b));
            wildcard_named_subs &amp;&amp; wildcard_named_subs.b &amp;&amp; (beforeSubscribersOutside=beforeSubscribersOutside.concat(wildcard_named_subs.b));
            named_wildcard_subs &amp;&amp; named_wildcard_subs.b &amp;&amp; (beforeSubscribersOutside=beforeSubscribersOutside.concat(named_wildcard_subs.b));
            wildcard_wildcard_subs &amp;&amp; wildcard_wildcard_subs.b &amp;&amp; (beforeSubscribersOutside=beforeSubscribersOutside.concat(wildcard_wildcard_subs.b));
            if (beforeSubscribersOutside.length&gt;0) {
                beforeSubscribersOutside = _filter(beforeSubscribersOutside, e);
                if (beforeSubscribersOutside.length&gt;0) {
                    _findCurrentTargets(beforeSubscribersOutside);
                    // sorting, based upon the sortFn
                    beforeSubscribersOutside.sort(_sortFunc);
                }
            }
        }

        // Emit the dom-event though our eventsystem:
        // NOTE: emit() needs to be synchronous! otherwise we wouldn&#x27;t be able
        // to preventDefault in time
        //
        // e = eventobject from the DOM-event OR gesture-event
        // eventobject = eventobject from our Eventsystem, which get returned by calling &#x60;emit()&#x60;


        eventobject = Event._emit(e.target, customEvent, e, beforeSubscribers, [], _preProcessor);
        outsideEvent &amp;&amp; (eventobjectOutside=Event._emit(e.target, customEvent+OUTSIDE, e, beforeSubscribersOutside, [], _preProcessor));

        // if eventobject was preventdefaulted or halted: take appropriate action on
        // the original dom-event. Note: only the original event can caused this, not the outsideevent
        // stopPropagation on the original eventobject has no impact on our eventsystem, but who know who else is watching...
        // be carefull though: not all gesture events have e.stopPropagation
        eventobject.status.halted &amp;&amp; e.stopPropagation &amp;&amp; e.stopPropagation();
        // now we might need to preventDefault the original event.
        // be carefull though: not all gesture events have e.preventDefault
        if ((eventobject.status.halted || eventobject.status.defaultPrevented) &amp;&amp; e.preventDefault) {
            e.preventDefault();
        }

        if (eventobject.status.ok) {
            // last step: invoke the aftersubscribers
            // we need to do this asynchronous: this way we pass them AFTER the DOM-event&#x27;s defaultFn
            // also make sure to paas-in the payload of the manipulated eventobject
            subs &amp;&amp; subs.a &amp;&amp; (afterSubscribers=afterSubscribers.concat(subs.a));
            wildcard_named_subs &amp;&amp; wildcard_named_subs.a &amp;&amp; (afterSubscribers=afterSubscribers.concat(wildcard_named_subs.a));
            named_wildcard_subs &amp;&amp; named_wildcard_subs.a &amp;&amp; (afterSubscribers=afterSubscribers.concat(named_wildcard_subs.a));
            wildcard_wildcard_subs &amp;&amp; wildcard_wildcard_subs.a &amp;&amp; (afterSubscribers=afterSubscribers.concat(wildcard_wildcard_subs.a));
            if (afterSubscribers.length&gt;0) {
                afterSubscribers = _filter(afterSubscribers, e);
                if (afterSubscribers.length&gt;0) {
                    _findCurrentTargets(afterSubscribers);
                    // sorting, based upon the sortFn
                    afterSubscribers.sort(_sortFunc);
                    async(Event._emit.bind(Event, e.target, customEvent, eventobject, [], afterSubscribers, _preProcessor, true), false);
                }
            }
            if (outsideEvent) {
                subs &amp;&amp; subs.a &amp;&amp; (afterSubscribersOutside=afterSubscribersOutside.concat(subs.a));
                wildcard_named_subs &amp;&amp; wildcard_named_subs.a &amp;&amp; (afterSubscribersOutside=afterSubscribersOutside.concat(wildcard_named_subs.a));
                named_wildcard_subs &amp;&amp; named_wildcard_subs.a &amp;&amp; (afterSubscribersOutside=afterSubscribersOutside.concat(named_wildcard_subs.a));
                wildcard_wildcard_subs &amp;&amp; wildcard_wildcard_subs.a &amp;&amp; (afterSubscribersOutside=afterSubscribersOutside.concat(wildcard_wildcard_subs.a));
                if (afterSubscribersOutside.length&gt;0) {
                    afterSubscribersOutside = _filter(afterSubscribersOutside, e);
                    if (afterSubscribersOutside.length&gt;0) {
                        _findCurrentTargets(afterSubscribersOutside);
                        // sorting, based upon the sortFn
                        afterSubscribersOutside.sort(_sortFunc);
                        async(Event._emit.bind(Event, e.target, customEvent+OUTSIDE, eventobjectOutside, [], afterSubscribersOutside, _preProcessor, true), false);
                    }
                }
            }
        }
    };

    _filter = function(subscribers, e) {
        console.log(NAME, &#x27;_filter&#x27;);
        var filtered = [];
        subscribers.forEach(
            function(subscriber) {
                console.log(NAME, &#x27;_filter for subscriber&#x27;);
                if (!subscriber.f || subscriber.f.call(subscriber.o, e)) {
                    filtered.push(subscriber);
                }
            }
        );
        return filtered;
    };

    _preProcessor = function(subscriber, e) {
        console.log(NAME, &#x27;_preProcessor&#x27;);
        // inside the aftersubscribers, we may need exit right away.
        // this would be the case whenever stopPropagation or stopImmediatePropagation was called
        // in case the subscribernode equals the node on which stopImmediatePropagation was called: return true
        var propagationStopped, immediatePropagationStopped,
            targetnode = (subscriber.t || subscriber.n);

        immediatePropagationStopped = e.status.immediatePropagationStopped;
        if (immediatePropagationStopped &amp;&amp; ((immediatePropagationStopped===targetnode) || !immediatePropagationStopped.contains(targetnode))) {
            console.log(NAME, &#x27;_preProcessor will return true because of immediatePropagationStopped&#x27;);
            return true;
        }
        // in case the subscribernode does not fall within or equals the node on which stopPropagation was called: return true
        propagationStopped = e.status.propagationStopped;
        if (propagationStopped &amp;&amp; (propagationStopped!==targetnode) &amp;&amp; !propagationStopped.contains(targetnode)) {
            console.log(NAME, &#x27;_preProcessor will return true because of propagationStopped&#x27;);
            return true;
        }

        e.currentTarget = subscriber.n;
        // now we might need to set e.target to the right node:
        // the filterfunction might have found the true domnode that should act as e.target
        // and set it at subscriber.t
        // also, we need to backup the original e.target: this one should be reset when
        // we encounter a subscriber with its own filterfunction instead of selector
        if (subscriber.t) {
            e.sourceTarget || (e.sourceTarget=e.target);
            e.target = subscriber.t;
        }
        else {
            e.sourceTarget &amp;&amp; (e.target=e.sourceTarget);
        }
        return false;
    };

    /*
     * Transports DOM-events to the Event-system. Catches events at their most early stage:
     * their capture-phase. When these events happen, a new customEvent is generated by our own
     * Eventsystem, by calling _evCallback(). This way we keep DOM-events and our Eventsystem completely separated.
     *
     * @method _setupDomListener
     * @param instanceEvent {Object} The Event-system
     * @param customEvent {String} the customEvent that is transported to the eventsystem
     * @private
     * @since 0.0.1
     */
    _setupDomListener = function(customEvent) {
        console.log(NAME, &#x27;_setupDomListener&#x27;);
        var eventSplitted = customEvent.split(&#x27;:&#x27;),
            eventName = eventSplitted[1],
            outsideEvent = REGEXP_UI_OUTSIDE.test(eventName);

        // be careful: anyone could also register an &#x60;outside&#x60;-event.
        // in those cases, the DOM-listener must be set up without &#x60;outside&#x60;
        outsideEvent &amp;&amp; (eventName=eventName.substring(0, eventName.length-7));

        // if eventName equals &#x60;mouseover&#x60; or &#x60;mouseleave&#x60; then we quit:
        // people should use &#x60;mouseover&#x60; and &#x60;mouseout&#x60;
        if ((eventName===&#x27;mouseenter&#x27;) || (eventName===&#x27;mouseleave&#x27;)) {
            console.warn(NAME, &#x27;Subscription to &#x27;+eventName+&#x27; not supported, use mouseover and mouseout: this eventsystem uses these non-noisy so they act as mouseenter and mouseleave&#x27;);
            return;
        }
        // already registered? then return, also return if someone registered for UI:*
        if (DOMEvents[eventName] || (eventName===&#x27;*&#x27;)) {
            // cautious: one might have registered the event, but not yet the outsideevent.
            // in that case: save this setting:
            outsideEvent &amp;&amp; (DOMEvents[eventName+OUTSIDE]=true);
            return;
        }

        if (NEW_EVENTSYSTEM) {
            // important: set the third argument &#x60;true&#x60; so we listen to the capture-phase.
            DOCUMENT.addEventListener(eventName, _evCallback, true);
        }
        else if (OLD_EVENTSYSTEM) {
            DOCUMENT.attachEvent(&#x27;on&#x27;+eventName, _evCallback);
        }
        DOMEvents[eventName] = true;
        outsideEvent &amp;&amp; (DOMEvents[eventName+OUTSIDE]=true);
    };

    /*
     *
     * @method _sortFunc
     * @param customEvent {String}
     * @private
     * @return {Function|undefined} sortable function
     * @since 0.0.1
     */
    _sortFunc = function(subscriberOne, subscriberTwo) {
        console.log(NAME, &#x27;_sortSubs&#x27;);
        return (subscriberTwo.t || subscriberTwo.n).contains(subscriberOne.t || subscriberOne.n) ? -1 : 1;
    };

    // Now we do some initialization in order to make DOM-events work:

    // Notify when someone subscriber to an UI:* event
    // if so: then we might need to define a customEvent for it:
    // alse define the specific DOM-methods that can be called on the eventobject: &#x60;stopPropagation&#x60; and &#x60;stopImmediatePropagation&#x60;
    Event.notify(&#x27;UI:*&#x27;, _setupDomListener, Event)
         ._setEventObjProperty(&#x27;stopPropagation&#x27;, function() {this.status.ok || (this.status.propagationStopped = this.target);})
         ._setEventObjProperty(&#x27;stopImmediatePropagation&#x27;, function() {this.status.ok || (this.status.immediatePropagationStopped = this.target);});

    // specify the emitter by emitterName UI
    Event.defineEmitter(window.HTMLElement.prototype, &#x27;UI&#x27;);

    // Event._domCallback is the only method that is added to Event.
    // We need to do this, because &#x60;event-mobile&#x60; needs access to the same method.
    // We could have done without this method and instead listen for a custom-event to handle
    // Mobile events, however, that would lead into 2 eventcycli which isn&#x27;t performant.

   /**
    * Does the actual transportation from DOM-events into the Eventsystem. It also looks at the response of
    * the Eventsystem: on e.halt() or e.preventDefault(), the original DOM-event will be preventDefaulted.
    *
    * @method _domCallback
    * @param eventName {String} the customEvent that is transported to the eventsystem
    * @param e {Object} eventobject
    * @private
    * @since 0.0.1
    */
    Event._domCallback = function(e) {
        _evCallback(e);
    };

    // whenever a subscriber gets defined with a css-selector instead of a filterfunction,
    // the event: &#x27;ParcelaEvent:selectorsubs&#x27; get emitted. We need to catch this event and transform its
    // selector into a filter-function:
    Event.after(PARCELA_EMITTER+&#x27;:selectorsubs&#x27;, _domSelToFunc, Event);

    // next: bubble-polyfill for IE8:
    OLD_EVENTSYSTEM &amp;&amp; _bubbleIE8();

    // store module:
    window.Parcela.modules.EventDom = Event;
    return Event;
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
