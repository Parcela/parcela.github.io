<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/io/io-stream.js - Parcela</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Parcela"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Parcel.html">Parcel</a></li>
            
                <li><a href="../classes/Parcel.EventListener.html">Parcel.EventListener</a></li>
            
                <li><a href="../classes/Parcel.Listener.html">Parcel.Listener</a></li>
            
                <li><a href="../classes/Parcela.html">Parcela</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/Router.html">Router</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vDOM.html">vDOM</a></li>
            
                <li><a href="../classes/vNode.html">vNode</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/core.html">core</a></li>
            
                <li><a href="../modules/core-routing.html">core-routing</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hammerjs.html">event-hammerjs</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-node.html">io-node</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-win.html">io-win</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/Object.html">Object</a></li>
            
                <li><a href="../modules/parcel.html">parcel</a></li>
            
                <li><a href="../modules/parcel-event-listener.html">parcel-event-listener</a></li>
            
                <li><a href="../modules/Parcela.html">Parcela</a></li>
            
                <li><a href="../modules/Promise.html">Promise</a></li>
            
                <li><a href="../modules/promise-ext.html">promise-ext</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/virtual-dom.html">virtual-dom</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/io/io-stream.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* globals XDomainRequest: true */

&quot;use strict&quot;;

var NAME = &#x27;[io-stream]: &#x27;,
    UNKNOW_ERROR = &#x27;Unknown XDR-error&#x27;, // XDR doesn&#x27;t specify the error
    REQUEST_TIMEOUT = &#x27;Request-timeout&#x27;,

    _entendXHR = function(xhr, props, options) {
        if (typeof options.streamback === &#x27;function&#x27;) {
            if (!props._isXHR2 &amp;&amp; !props._isXDR) {
                if (typeof XDomainRequest !== &#x27;undefined&#x27;) {
                    xhr = new XDomainRequest();
                    props._isXDR = true;
                }
            }
            props._isStream = props._isXHR2 || props._isXDR;
        }

    // TODO: check how to deal with opera-mini

        return xhr;
    },

    _progressHandle = function(xhr, promise, headers, method) {
        if (xhr._isStream) {
            console.log(NAME, &#x27;progressHandle&#x27;);
            xhr._progressPos = 0;
            xhr.onprogress = function() {
                console.log(NAME, &#x27;xhr.onprogress received data #&#x27;+xhr.response+&#x27;#&#x27;);
                promise.callback(xhr.response.substr(xhr._progressPos));
                xhr._progressPos = xhr.response.length;
            };
        }
    },

    _readyHandleXDR = function(xhr, promise, headers, method) {
        if (xhr._isXDR) {
            console.log(NAME, &#x27;readyHandleXDR&#x27;);
            // for XDomainRequest, we need &#x27;onload&#x27; instead of &#x27;onreadystatechange&#x27;
            xhr.onload = function() {
                clearTimeout(xhr._timer);
                console.log(NAME, &#x27;xhr.onload invokes with responseText=&#x27;+xhr.responseText);
                promise.fulfill(xhr);
            };
            xhr.onerror = function() {
                clearTimeout(xhr._timer);
                promise.reject(UNKNOW_ERROR);
            };
        }
    },

    _setStreamHeader = function(xhr, promise, headers, method) {
        if (xhr._isStream &amp;&amp; !xhr._isXDR) {
            console.log(NAME, &#x27;_setStreamHeader&#x27;);
            xhr.setRequestHeader(&#x27;X-Stream&#x27;, &#x27;true&#x27;);
        }
    },

    IO_Stream = {
        mergeInto: function (io) {
            io._xhrList.push(_entendXHR);
            io._xhrInitList.push(_readyHandleXDR);
            io._xhrInitList.push(_progressHandle);
            io._xhrInitList.push(_setStreamHeader);
        }
    };

module.exports = IO_Stream;


/**
 * Initiates the &#x60;XMLHttpRequest()&#x60;-instance. Tries to use XMLHttpRequest2, which is supported by all modern browsers except IE&lt;10
 * if XMLHttpRequest2 fails, it will try to use IE&#x27;s XDomainRequest.
 *
 * The returned xhr DOES support CORS for all modern browsers.
 * To use CORS, you need to setup the responseserver right
 * More info about CORS: http://remysharp.com/2011/04/21/getting-cors-working/
 *
 * Using CORS with IE9-browsers need special consideration, for it uses the XDomainRequest():
 * 1. Only GET and POST methods are supported. Other methods will be reset into one of these,
 *    so make sure the cross-domain-server handles all requests as being send with the GET or POST method.
 * 2. Only text/plain is supported for the request&#x27;s Content-Type header. This will lead into troubles when handling
 *    POST-requests: the cross-domain-server needs to extract the parameters itself. For nodejs, there is a nice npm module:
 *    &#x60;express-ie-cors&#x60; https://github.com/advanced/express-ie-cors/blob/master/lib/express-ie-cors.js
 * 3. No custom headers can be added to the request.
 * 4. No authentication or cookies will be sent with the request.
 * more info: http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
 *
 * @method _createXHR
 * @param url {String} in case XMLHttpRequest2 is not available, we must determine whether to create a crossdomain-request
 * @return {XMLHttpRequest2|XMLHttpRequest|XDomainRequest} xhr-instance
 * @private
*/

    // NOT_ARRAY_ITEMS = &#x27;response is no array&#x27;,





/*

/**
 * Sends a HTTP request to the server and returns a Promise with an additional .abort() method to cancel the request.
 * Uses &#x60;Promise.stream&#x60;, defined inside the &#x60;core-promiseext&#x60; module
 *
 * @method _xhrStream
 * @param streamback {Function} callbackfunction to process stream-information. Streamed data is available inside the argument if the callback.
 * @param options {Object}
 *    @param [options.url] {String} The url to which the request is sent.
 *    @param [options.method=&#x27;GET&#x27;] {String} The HTTP method to use.
 *    can be ignored, even if streams are used --&gt; the returned Promise will always hold all data
 *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
 *    @param [options.params] {Object} Data to be sent to the server.
 *    @param [options.body] {Object} The content for the request body for POST method.
 *    @param [options.headers] {Object} HTTP request headers.
 *    @param [options.responseType=&#x27;text&#x27;] {String} The response type.
 *    @param [options.timeout=3000] {number} to timeout the request, leading into a rejected Promise.
 *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
 * @return {Promise} Promise holding the request. Has an additional .abort() method to cancel the request.
 * on success:
    * data {Array} holding the streamed items: each response is a String-item in the array
 * on failure an Error object
    * reason {Error}
 * @private
*/

/*

IO._xhrStream = function(streamback, options) {
    console.log(NAME, &#x27;_xhrStream&#x27;);
    var instance = this,
        xhr = instance._createXHR(options.url),
        promise;
    promise = Promise.stream(streamback);
    // xhr will be null in case of a CORS-request when no CORS is posible
    xhr ? instance._initXHR(xhr, options, promise.ready, promise.error, promise, true) : promise.reject(ERROR_NO_CORS);
    return promise;
};

/**
 * Sends a HTTP request to the server and returns a Promise with an additional .abort() method to cancel the request.
 *
 * The promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range.
 * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
 *
 * CORS is supported, as long as the responseserver is set up to:
 *      a) has a response header which allows the clientdomain:
 *         header(&#x27;Access-Control-Allow-Origin: http://www.some-site.com&#x27;); or header(&#x27;Access-Control-Allow-Origin: *&#x27;);
 *      b) in cae you have set a custom HEADER (through &#x27;options&#x27;), the responseserver MUST listen and respond
 *         to requests with the OPTION-method
 *      More info:  allows to send to your domain: see http://remysharp.com/2011/04/21/getting-cors-working/
 *
 * @method xhr
 * @param [options] {Object}
 *    @param [options.url] {String} The url to which the request is sent.
 *    @param [options.method=&#x27;GET&#x27;] {String} The HTTP method to use.
 *    @param [options.streamback] {Function} callbackfunction in case you want to process streams.
 *    can be ignored, even if streams are used --&gt; the returned Promise will always hold all data
 *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
 *    @param [options.params] {Object} Data to be sent to the server.
 *    @param [options.body] {Object} The content for the request body for POST method.
 *    @param [options.headers] {Object} HTTP request headers.
 *    @param [options.responseType=&#x27;text&#x27;] {String} The response type.
 *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
 *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
 * @return {Promise} Promise holding the request. Has an additional .abort() method to cancel the request.
 * on success:
    * data {Array|Any} in case &#x60;streamback&#x60; is set, data will always be an array, otherwise its the plain serverresponse.
    * xhr {XMLHttpRequest|XDomainRequest} xhr-response, in case &#x60;streamback&#x60; is set, with an extra property:
          &#x60;xhr.data&#x60; {Array} an array where every single stream-resonse is an array-item
 * on failure an Error object
    * reason {Error}
*/

/*

IO.xhr = function(options) {
    console.log(NAME, &#x27;xhr&#x27;);
    var instance = this,
        streamback;
    options || (options={});
    // if &#x60;window&#x60; is undefined, we assume a NodeJS environment
    return (streamback=options.streamback) ? instance._xhrStream(streamback, options) : instance._xhr(options);
};

    /**
     * Sends a HTTP request to the server and returns a Promise with an additional .abort() method to cancel the request.
     * This method is the standard way of doing xhr-requests without processing streams.
     *
     * @method _xhr
     * @param options {Object}
     *    @param [options.url] {String} The url to which the request is sent.
     *    @param [options.method=&#x27;GET&#x27;] {String} The HTTP method to use.
     *    can be ignored, even if streams are used --&gt; the returned Promise will always hold all data
     *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
     *    @param [options.params] {Object} Data to be sent to the server.
     *    @param [options.body] {Object} The content for the request body for POST method.
     *    @param [options.headers] {Object} HTTP request headers.
     *    @param [options.responseType=&#x27;text&#x27;] {String} The response type.
     *    @param [options.timeout=3000] {number} to timeout the request, leading into a rejected Promise.
     *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
     * @return {Promise} Promise holding the request. Has an additional .abort() method to cancel the request.
     * on success:
        * xhr {XMLHttpRequest|XDomainRequest} xhr-response
     * on failure an Error object
        * reason {Error}
     * @private
    */

/*

    IO._xhr: function(options) {
        console.log(NAME, &#x27;_xhr&#x27;);
        var instance = this,
            promise, fulfilledHandle, rejectHandle, xhr;
        options || (options={});
        promise = new Promise(function(fulfill, reject) {
            fulfilledHandle = fulfill;
            rejectHandle = reject;
        });
        xhr = instance._createXHR();
        xhr.timeout = options.timeout || (isStream &amp;&amp; (instance.config.reqTimeout || DEF_REQ_TIMEOUT));
        instance._initXHR(xhr, options, fulfilledHandle, rejectHandle, promise);
        return promise;
    };
};


        // now define methods which listen for the xhr-events:
        xhr._isXDR ? instance._setReadyHandleXDR(xhr, fulfill, reject) : instance._setReadyHandle(xhr, fulfill, reject);
        isStream &amp;&amp; instance._setProgressHandle(xhr, promise);


            /**
     * Adds the &#x60;xhr.onprogress()&#x60; method on the xhr-instance which is used by xhr when events occur.
     *
     * This events is responsible for sending partial data to the streamcallback
     *
     * @method _setProgressHandle
     * @param xhr {Object} containing the xhr-instance
     * @param promise {Promise} reference to the Promise created by _xhr
     * @private
    */

/*

    IO._setProgressHandle: function(xhr, promise) {
        console.log(NAME, &#x27;_setProgressHandle&#x27;);
        xhr._progressPos = 0;
        xhr.onprogress = function() {
            console.log(NAME, &#x27;xhr.onprogress received data&#x27;);
            promise.add(this.response.substr(xhr._progressPos));
            xhr._progressPos = this.response.length;
        };
    };


/**
 * Performs an AJAX GET request.  Shortcut for a call to [&#x60;xhr&#x60;](#method_xhr) with &#x60;method&#x60; set to  &#x60;&#x27;GET&#x27;&#x60;.
 * Expects the server to response streamwise (though not necessary).
 *
 * Additional parameters can be on the url (with questionmark), through &#x60;params&#x60;, or both.
 *
 * You can use the &#x60;streamback&#x60; function to process intermediate serverresponses
 * The resolved Promise-callback returns an array where each item represents a serverresponse.
 *
 * The Promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range (excluded 204).
 * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
 *
 * @method getStream
 * @param url {String} URL of the resource server
 * @param [params] {Object} additional parameters.
 * @param streamback {Function} callbackfunction to process stream-information. Streamed data is available inside the argument if the callback.
 * @param [options] {Object}
 *    @param [options.url] {String} The url to which the request is sent.
 *    can be ignored, even if streams are used --&gt; the returned Promise will always hold all data
 *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
 *    @param [options.params] {Object} Data to be sent to the server.
 *    @param [options.body] {Object} The content for the request body for POST method.
 *    @param [options.headers] {Object} HTTP request headers.
 *    @param [options.responseType=&#x27;text&#x27;] {String} The response type.
 *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
 *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
 * @return {Promise}
 * on success:
    * data {Array} holding the streamed items: each response is a String-item in the array
 * on failure an Error object
    * reason {Error}
*/

/*
IO_Class.prototype.getStream = function (url, params, streamback, options) {
    console.log(NAME, &#x27;I.IO.getStream  --&gt; &#x27;+url+&#x27; params: &#x27;+JSON.stringify(params));
    options || (options={});
    options.url = url;
    // method will be uppercased by IO.xhr
    options.params = params;
    options.streamback = streamback;
    return this.xhr(options);
};

/**
 * Performs an AJAX request with the GET HTTP method.
 * Expects the server to response a JSON-array or JSON-object.
 * Expects the server to response streamwise (though not necessary). A typical usage would be
 * to response with small array-subsets.
 *
 * &#x60;streamback&#x60; gets invoked with every streamed response, passing an array at its argument which holds
 * the items of this partial response.
 * The resolved Promise-callback returns an array which holds all the items.
 *
 * Additional request-parameters can be on the url (with questionmark), through &#x60;params&#x60;, or both.
 *
 * The Promise gets fulfilled if the server responses with &#x60;STATUS-CODE&#x60; in the 200-range (excluded 204).
 * It will be rejected if a timeout occurs (see &#x60;options.timeout&#x60;), or if &#x60;xhr.abort()&#x60; gets invoked.
 *
 * Note1: CORS is supported, as long as the responseserver is set up to:
 *       a) has a response header which allows the clientdomain:
 *          header(&#x27;Access-Control-Allow-Origin: http://www.some-site.com&#x27;); or header(&#x27;Access-Control-Allow-Origin: *&#x27;);
 *       b) in cae you have set a custom HEADER (through &#x27;options&#x27;), the responseserver MUST listen and respond
 *          to requests with the OPTION-method
 *       More info:  allows to send to your domain: see http://remysharp.com/2011/04/21/getting-cors-working/
 * Note2: If you expect the server to response with data that consist of Date-properties, you should set &#x60;options.parseJSONDate&#x60; true.
 *        Parsing takes a bit longer, but it will generate trully Date-objects.
 *
 * @method readStreamedArray
 * @param url {String} URL of the resource server
 * @param [params] {Object} additional parameters.
 * @param [streamback] {Function} function with 1 argument (items) which gets invoked on every partial response.
 * @param [options] {Object} See also: [&#x60;I.io&#x60;](#method_xhr)
 *    @param [options.url] {String} The url to which the request is sent.
 *    can be ignored, even if streams are used --&gt; the returned Promise will always hold all data
 *    @param [options.sync=false] {boolean} By default, all requests are sent asynchronously. To send synchronous requests, set to true.
 *    @param [options.params] {Object} Data to be sent to the server.
 *    @param [options.body] {Object} The content for the request body for POST method.
 *    @param [options.headers] {Object} HTTP request headers.
 *    @param [options.responseType=&#x27;text&#x27;] {String} The response type.
 *    @param [options.timeout=3000] {Number} to timeout the request, leading into a rejected Promise.
 *    @param [options.withCredentials=false] {boolean} Whether or not to send credentials on the request.
 *    @param [options.parseJSONDate=false] {boolean} Whether the server returns JSON-stringified data which has Date-objects.
 * @return {Promise}
 * on success:
    * Object received data
 * on failure an Error object
    * reason {Error}
*/

/*
IO_Class.prototype.readStreamedArray = function(url, params, streamback, options) {
    console.log(NAME, &#x27;I.IO.readObject  --&gt; &#x27;+url+&#x27; params: &#x27;+JSON.stringify(params));
    var totalarray = [],
        ioStream, parseError;
    options || (options={});
    ioStream = function(partialdata) {
        console.log(NAME, &#x27;IO.readStreamedArray receives partial data: &#x27;+partialdata);
        var newdata;
        try {
            newdata = JSON.parse(partialdata, (options.parseJSONDate) ? REVIVER : null);
            streamback(newdata);
            Array.prototype.push.apply(totalarray, Array.isArray(newdata) ? newdata : [newdata]);
        }
        catch (err) {
            console.warn(NAME, &#x27;IO.readStreamedArray cannot parse partial data: &#x27;+NOT_ARRAY_ITEMS);
            parseError = true;
        }
    };
    return this.getStream(url, params, ioStream, options).then(
        function(alldata) {
            // first check if there was a parseError on the initial data
            if (parseError) {
                console.warn(NAME, &#x27;IO.readStreamedArray will reject because of partial parse-error: &#x27;+NOT_ARRAY_ITEMS);
                throw new Error(NOT_ARRAY_ITEMS);
            }
            // in case no partial response happened, all data might have got within 1 request:
            try {
                (totalarray.length===0) &amp;&amp; (totalarray=JSON.parse(alldata, (options.parseJSONDate) ? REVIVER : null));
            }
            catch (err) {
                console.warn(NAME, &#x27;IO.readStreamedArray will reject because of parse-error: &#x27;+NOT_ARRAY_ITEMS);
                throw new Error(NOT_ARRAY_ITEMS);
            }
            console.log(NAME, &#x27;IO.readStreamedArray returns with: &#x27;+JSON.stringify(totalarray));
            return totalarray;
        }
    );
};

    */

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
