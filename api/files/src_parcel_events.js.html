<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/parcel/events.js - Parcela</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Parcela"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Parcel.html">Parcel</a></li>
            
                <li><a href="../classes/Parcel.EventListener.html">Parcel.EventListener</a></li>
            
                <li><a href="../classes/Parcel.Listener.html">Parcel.Listener</a></li>
            
                <li><a href="../classes/Parcela.html">Parcela</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/Promise.Resolver.html">Promise.Resolver</a></li>
            
                <li><a href="../classes/Router.html">Router</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/vDOM.html">vDOM</a></li>
            
                <li><a href="../classes/vNode.html">vNode</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/core.html">core</a></li>
            
                <li><a href="../modules/core-event.html">core-event</a></li>
            
                <li><a href="../modules/core-event-base.html">core-event-base</a></li>
            
                <li><a href="../modules/core-routing.html">core-routing</a></li>
            
                <li><a href="../modules/core-timers.html">core-timers</a></li>
            
                <li><a href="../modules/core-utils.html">core-utils</a></li>
            
                <li><a href="../modules/core-vdom.html">core-vdom</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hammerjs.html">event-hammerjs</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-node.html">io-node</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-win.html">io-win</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/Object.html">Object</a></li>
            
                <li><a href="../modules/parcel.html">parcel</a></li>
            
                <li><a href="../modules/parcel-event-listener.html">parcel-event-listener</a></li>
            
                <li><a href="../modules/Parcela.html">Parcela</a></li>
            
                <li><a href="../modules/Promise.html">Promise</a></li>
            
                <li><a href="../modules/promise-ext.html">promise-ext</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
                <li><a href="../modules/virtual-dom.html">virtual-dom</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/parcel/events.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* globals document:true */

&quot;use strict&quot;;

/**
 * Extends the Event-instance by adding the object &#x60;listener&#x60; to it.
 * The returned object should be merged into any Class-instance or object you want to
 * extend with the listener-methods, so the appropriate methods can be invoked on the instance.
 *
 * Should be called using  the provided &#x60;extend&#x60;-method like this:
 * @example
 *     var coreEventListener = require(&#x27;core-event-listener&#x27;);&lt;br&gt;
 *     coreEventListener.extend(ITSA.event);
 *
 * @module parcel
 * @submodule parcel-event-listener
 * @class Parcel.Listener
 * @since 0.0.1
 *
 * &lt;i&gt;Copyright (c) 2014 Parcela - https://github.com/Parcela&lt;/i&gt;
 * New BSD License - https://github.com/ItsAsbreuk/itsa-library/blob/master/LICENSE
 *
*/

// Include Function.mergePrototypes:
require(&#x27;lang-ext&#x27;);
var NAME = &#x27;[parcel-events]: &#x27;,
    PARCELA_EMITTER = &#x27;ParcelaEvent&#x27;,
    REGEXP_NODE_ID = /^#\S+$/,
    REGEXP_EXTRACT_NODE_ID = /#(\S+)/,
    REGEXP_UI_OUTSIDE = /^.+outside$/;

module.exports = function (window) {

    require(&#x27;event/event-emitter.js&#x27;);

    var Event = require(&#x27;event-dom&#x27;)(window),
        DOCUMENT = window.document,
        _parcelSelToFunc;

    /*
     * Creates a filterfunction out of a css-selector. To be used for catching any dom-element, without restrictions
     * of any context (like Parcels can --&gt; Parcel.Event uses _parcelSelToDom instead)
     * On &quot;non-outside&quot; events, subscriber.t is set to the node that first matches the selector
     * so it can be used to set as e.target in the final subscriber
     *
     * @method _parcelSelToFunc
     * @param ev {Object} eventobject
     * @param ev.subscriber {Object} subscriber
     * @param ev.subscriber.o {Object} context
     * @param ev.subscriber.cb {Function} callbackFn
     * @param ev.subscriber.f {Function|String} filter
     * @param ev.subscriber.n {dom-node} becomes e.currentTarget
     * @param ev.subscriber.t {dom-node} becomes e.target
     * @param ev.customEvent {String}
     * @private
     * @since 0.0.1
     */
    _parcelSelToFunc = function(ev) {
        // this stage is runned during subscription
        var selector = ev.subscriber.f,
            parcelinstance = ev.subscriber.o,
            nodeid, byExactId, outsideEvent;

        if ((typeof parcelinstance.stamp!==&#x27;function&#x27;) || (typeof parcelinstance.view!==&#x27;function&#x27;)) {
            // no parceltinstance: exit
            return;
        }
        console.log(NAME, &#x27;_parcelSelToFunc type of selector = &#x27;+typeof selector);

        // in case of no selector: we still need to process: parcelinstance._pNode becomes the currentTarget
        // to match against. Thus only leave when selector is a function
        if (typeof selector === &#x27;function&#x27;) {
            ev.subscriber.n || (ev.subscriber.n=DOCUMENT);
            return;
        }

        outsideEvent = REGEXP_UI_OUTSIDE.test(ev.customEvent);

        if (selector) {
            nodeid = selector.match(REGEXP_EXTRACT_NODE_ID);
            // do need to set ev.subscriber.n, otherwise filtering goes wrong
            nodeid ? (ev.subscriber.nId=nodeid[1]) : (ev.subscriber.n=DOCUMENT);

            byExactId = REGEXP_NODE_ID.test(selector);

            ev.subscriber.f = function(e) {
                // this stage is runned when the event happens
                console.log(NAME, &#x27;_parcelSelToFunc inside filter&#x27;);
                var node = e.target,
                    pNode_node = parcelinstance._pNode &amp;&amp; parcelinstance._pNode.node,
                    match = false,
                    pvNodeInfo;

                // e.target is the most deeply node in the dom-tree that caught the event
                // our listener uses &#x60;selector&#x60; which might be a node higher up the tree.
                // we will reset e.target to this node (if there is a match)
                // note that e.currentTarget will always be &#x60;document&#x60; --&gt; we&#x27;re not interested in that
                // also, we don&#x27;t check for &#x60;node&#x60;, but for node.matchesSelector: the highest level &#x60;document&#x60;
                // is not null, yet it doesn;t have .matchesSelector so it would fail
                while (pNode_node.contains(node) &amp;&amp; !match) {
                    console.log(NAME, &#x27;_parcelSelToFunc inside filter check match&#x27;);
                    if (byExactId) {
                        match = (node.id===selector.substr(1)) &amp;&amp; ((node===pNode_node) || pNode_node.contains(node));
                    }
                    else {
                        match = node.matchesSelector(selector);
                    }
                    // if there is a match, then set
                    // e.target to the target that matches the selector
                    if (match &amp;&amp; !outsideEvent) {
                        ev.subscriber.t = node;
                    }
                    node = node.parentNode;
                }
                console.log(NAME, &#x27;_parcelSelToFunc filter returns &#x27;+(!outsideEvent ? match : !match));
                return !outsideEvent ? match : !match;
            };
        }
        else {
            ev.subscriber.f = function(e) {
                // this stage is runned when the event happens
                console.log(NAME, &#x27;_parcelSelToFunc inside filter&#x27;);
                var node = e.target,
                    pNode_node = parcelinstance._pNode &amp;&amp; parcelinstance._pNode.node,

                match = ((node===pNode_node) || pNode_node.contains(node));
                return !outsideEvent ? match : !match;
            };
        }
    };
    // whenever a subscriber gets defined with a css-selector instead of a filterfunction,
    // the event: &#x27;ParcelaEvent:selectorsubs&#x27; get emitted. We need to catch this event and transform its
    // selector into a filter-function:
    Event.after(PARCELA_EMITTER+&#x27;:selectorsubs&#x27;, _parcelSelToFunc, Event, true);

    return {
        mergeInto: function(ParcelClass) {
            ParcelClass.mergePrototypes({

                /**
                 * Defines an emitterName into the instance.
                 * This will add a protected property &#x60;_emitterName&#x60; to the instance. If you need an emitterName on
                 * the Class, you should use the Event.Emitter helper: &#x60;ClassName.mergePrototypes(Event.Emitter(emitterName));&#x60;
                 *
                 * @static
                 * @method defineEmitter
                 * @param emitterName {String} identifier that will be added when events are sent (&#x60;emitterName:eventName&#x60;)
                 * @since 0.0.1
                */
                defineEmitter: function(emitterName) {
                     // force assign: there might be an emittername on the Class
                    this.merge(Event.Emitter(emitterName), true);
                },

                /**
                 * Subscribes to a customEvent on behalf of the object who calls this method.
                 * The callback will be executed &#x60;after&#x60; the defaultFn.
                 *
                 * @method after
                 * @param customEvent {String|Array} the custom-event (or Array of events) to subscribe to. CustomEvents should
                 *        have the syntax: &#x60;emitterName:eventName&#x60;. Wildcard &#x60;*&#x60; may be used for both &#x60;emitterName&#x60; as well as &#x60;eventName&#x60;.
                 *        If &#x60;emitterName&#x60; is not defined, &#x60;UI&#x60; is assumed.
                 * @param callback {Function} subscriber:will be invoked when the event occurs. An &#x60;eventobject&#x60; will be passed
                 *        as its only argument.
                 * @param [filter] {String|Function} to filter the event.
                 *        Use a String if you want to filter DOM-events by a &#x60;selector&#x60;
                 *        Use a function if you want to filter by any other means. If the function returns a trully value, the
                 *        subscriber gets invoked. The function gets the &#x60;eventobject&#x60; as its only argument and the context is
                 *        the subscriber.
                 * @param [prepend=false] {Boolean} whether the subscriber should be the first in the list of after-subscribers.
                 * @return {Object} handler with a &#x60;detach()&#x60;-method which can be used to detach the subscriber
                 * @since 0.0.1
                */
                after: function (customEvent, callback, filter, prepend) {
                    return Event.after(customEvent, callback, this, filter, prepend);
                },

                /**
                 * Subscribes to a customEvent on behalf of the object who calls this method.
                 * The callback will be executed &#x60;before&#x60; the defaultFn.
                 *
                 * @method before
                 * @param customEvent {String|Array} the custom-event (or Array of events) to subscribe to. CustomEvents should
                 *        have the syntax: &#x60;emitterName:eventName&#x60;. Wildcard &#x60;*&#x60; may be used for both &#x60;emitterName&#x60; as well as &#x60;eventName&#x60;.
                 *        If &#x60;emitterName&#x60; is not defined, &#x60;UI&#x60; is assumed.
                 * @param callback {Function} subscriber:will be invoked when the event occurs. An &#x60;eventobject&#x60; will be passed
                 *        as its only argument.
                 * @param [filter] {String|Function} to filter the event.
                 *        Use a String if you want to filter DOM-events by a &#x60;selector&#x60;
                 *        Use a function if you want to filter by any other means. If the function returns a trully value, the
                 *        subscriber gets invoked. The function gets the &#x60;eventobject&#x60; as its only argument and the context is
                 *        the subscriber.
                 * @param [prepend=false] {Boolean} whether the subscriber should be the first in the list of before-subscribers.
                 * @return {Object} handler with a &#x60;detach()&#x60;-method which can be used to detach the subscriber
                 * @since 0.0.1
                */
                before: function (customEvent, callback, filter, prepend) {
                    return Event.before(customEvent, callback, this, filter, prepend);
                },

                /**
                 * Detaches (unsubscribes) the listener from the specified customEvent,
                 * on behalf of the object who calls this method.
                 *
                 * @method detach
                 * @param customEvent {String} conform the syntax: &#x60;emitterName:eventName&#x60;, wildcard &#x60;*&#x60; may be used for both
                 *        &#x60;emitterName&#x60; as well as only &#x60;eventName&#x60;, in which case &#x27;UI&#x27; will become the emitterName.
                 * @since 0.0.1
                */
                detach: function(customEvent) {
                    Event.detach(this, customEvent);
                },

                /**
                 * Detaches (unsubscribes) the listener from all customevents,
                 * on behalf of the object who calls this method.
                 *
                 * @method detachAll
                 * @since 0.0.1
                */
                detachAll: function() {
                    Event.detachAll(this);
                },

                /**
                 * Alias for &#x60;after&#x60;.
                 *
                 * Subscribes to a customEvent on behalf of the object who calls this method.
                 * The callback will be executed &#x60;after&#x60; the defaultFn.
                 *
                 * @method on
                 * @param customEvent {String|Array} the custom-event (or Array of events) to subscribe to. CustomEvents should
                 *        have the syntax: &#x60;emitterName:eventName&#x60;. Wildcard &#x60;*&#x60; may be used for both &#x60;emitterName&#x60; as well as &#x60;eventName&#x60;.
                 *        If &#x60;emitterName&#x60; is not defined, &#x60;UI&#x60; is assumed.
                 * @param callback {Function} subscriber:will be invoked when the event occurs. An &#x60;eventobject&#x60; will be passed
                 *        as its only argument.
                 * @param [filter] {String|Function} to filter the event.
                 *        Use a String if you want to filter DOM-events by a &#x60;selector&#x60;
                 *        Use a function if you want to filter by any other means. If the function returns a trully value, the
                 *        subscriber gets invoked. The function gets the &#x60;eventobject&#x60; as its only argument and the context is
                 *        the subscriber.
                 * @param [prepend=false] {Boolean} whether the subscriber should be the first in the list of after-subscribers.
                 * @return {Object} handler with a &#x60;detach()&#x60;-method which can be used to detach the subscriber
                 * @since 0.0.1
                */
                on: function (/* customEvent, callback, filter, prepend */) {
                    return this.after.apply(this, arguments);
                },

                /**
                 * Alias for &#x60;onceAfter&#x60;.
                 *
                 * Subscribes to a customEvent on behalf of the object who calls this method.
                 * The callback will be executed &#x60;after&#x60; the defaultFn.
                 * The subscriber will be automaticly removed once the callback executed the first time.
                 * No need to &#x60;detach()&#x60; (unless you want to undescribe before the first event)
                 *
                 * @method onceAfter
                 * @param customEvent {String|Array} the custom-event (or Array of events) to subscribe to. CustomEvents should
                 *        have the syntax: &#x60;emitterName:eventName&#x60;. Wildcard &#x60;*&#x60; may be used for both &#x60;emitterName&#x60; as well as &#x60;eventName&#x60;.
                 *        If &#x60;emitterName&#x60; is not defined, &#x60;UI&#x60; is assumed.
                 * @param callback {Function} subscriber:will be invoked when the event occurs. An &#x60;eventobject&#x60; will be passed
                 *        as its only argument.
                 * @param [filter] {String|Function} to filter the event.
                 *        Use a String if you want to filter DOM-events by a &#x60;selector&#x60;
                 *        Use a function if you want to filter by any other means. If the function returns a trully value, the
                 *        subscriber gets invoked. The function gets the &#x60;eventobject&#x60; as its only argument and the context is
                 *        the subscriber.
                 * @param [prepend=false] {Boolean} whether the subscriber should be the first in the list of after-subscribers.
                 * @return {Object} handler with a &#x60;detach()&#x60;-method which can be used to detach the subscriber
                 * @since 0.0.1
                */
                once: function (/* customEvent, callback, filter, prepend */) {
                    return this.onceAfter.apply(this, arguments);
                },

                /**
                 * Subscribes to a customEvent on behalf of the object who calls this method.
                 * The callback will be executed &#x60;after&#x60; the defaultFn.
                 * The subscriber will be automaticly removed once the callback executed the first time.
                 * No need to &#x60;detach()&#x60; (unless you want to undescribe before the first event)
                 *
                 * @method onceAfter
                 * @param customEvent {String|Array} the custom-event (or Array of events) to subscribe to. CustomEvents should
                 *        have the syntax: &#x60;emitterName:eventName&#x60;. Wildcard &#x60;*&#x60; may be used for both &#x60;emitterName&#x60; as well as &#x60;eventName&#x60;.
                 *        If &#x60;emitterName&#x60; is not defined, &#x60;UI&#x60; is assumed.
                 * @param callback {Function} subscriber:will be invoked when the event occurs. An &#x60;eventobject&#x60; will be passed
                 *        as its only argument.
                 * @param [filter] {String|Function} to filter the event.
                 *        Use a String if you want to filter DOM-events by a &#x60;selector&#x60;
                 *        Use a function if you want to filter by any other means. If the function returns a trully value, the
                 *        subscriber gets invoked. The function gets the &#x60;eventobject&#x60; as its only argument and the context is
                 *        the subscriber.
                 * @param [prepend=false] {Boolean} whether the subscriber should be the first in the list of after-subscribers.
                 * @return {Object} handler with a &#x60;detach()&#x60;-method which can be used to detach the subscriber
                 * @since 0.0.1
                */
                onceAfter: function (customEvent, callback, filter, prepend) {
                    return Event.onceAfter(customEvent, callback, this, filter, prepend);
                },

                /**
                 * Subscribes to a customEvent on behalf of the object who calls this method.
                 * The callback will be executed &#x60;before&#x60; the defaultFn.
                 * The subscriber will be automaticly removed once the callback executed the first time.
                 * No need to &#x60;detach()&#x60; (unless you want to undescribe before the first event)
                 *
                 * @method onceBefore
                 * @param customEvent {String|Array} the custom-event (or Array of events) to subscribe to. CustomEvents should
                 *        have the syntax: &#x60;emitterName:eventName&#x60;. Wildcard &#x60;*&#x60; may be used for both &#x60;emitterName&#x60; as well as &#x60;eventName&#x60;.
                 *        If &#x60;emitterName&#x60; is not defined, &#x60;UI&#x60; is assumed.
                 * @param callback {Function} subscriber:will be invoked when the event occurs. An &#x60;eventobject&#x60; will be passed
                 *        as its only argument.
                 * @param [filter] {String|Function} to filter the event.
                 *        Use a String if you want to filter DOM-events by a &#x60;selector&#x60;
                 *        Use a function if you want to filter by any other means. If the function returns a trully value, the
                 *        subscriber gets invoked. The function gets the &#x60;eventobject&#x60; as its only argument and the context is
                 *        the subscriber.
                 * @param [prepend=false] {Boolean} whether the subscriber should be the first in the list of before-subscribers.
                 * @return {Object} handler with a &#x60;detach()&#x60;-method which can be used to detach the subscriber
                 * @since 0.0.1
                */
                onceBefore: function (customEvent, callback, filter, prepend) {
                    return Event.onceBefore(customEvent, callback, this, filter, prepend);
                }
            });

        }
    };
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
